// (C) Uri Wilensky. https://github.com/NetLogo/NetLogo

package org.nlogo.headless
package lang
package misc

// Most testing of error messages can go in autogen/tests/commands.  Some tests are here because
// they go beyond the capabilities of the autogenerated test framework.  (In the long run, perhaps
// that framework should be extended so these tests could be done in it.)  - ST 3/18/08
import org.nlogo.{ api, nvm }
import org.nlogo.util.SlowTest

class TestErrorMessages extends FixtureSuite with SlowTest {

  // Here we're testing not just that the error message is right, but that
  // the error is attributed to the right agent.  So we intercept
  // EngineException, not just generic LogoException, and look inside.

  test("perspectiveChangeWithOf") { fixture =>
    import fixture._
    testCommand(
      "create-frogs 3 [ set spots turtle ((who + 1) mod count turtles) ]")
    testCommand(
      "ask frog 2 [ die ]")
    val ex = intercept[nvm.EngineException] {
      testCommand(
        "ask turtle 0 [ __ignore [who] of frogs with " +
        "[age = ([age] of [spots] of self)]]")
    }
    assertResult("That frog is dead.")(ex.getMessage)
    // frog 2 is dead, but frog 1 actually encountered the error
    assertResult("frog 1")(ex.context.agent.toString)
  }

  // Here we're checking that when a runtime error is reported, the right
  // token is singled out as the source of the error.

  test("argumentTypeException") { fixture =>
    import fixture._
    testCommand("set glob1 [1.4]")
    val ex = intercept[nvm.ArgumentTypeException] {
      testCommand("__ignore 0 < position 5 item 0 glob1") }
    val message =
      "POSITION expected input to be a string or list but got the number 1.4 instead."
    assertResult(message)(ex.getMessage)
    assertResult("POSITION")(ex.instruction.token.text.toUpperCase)
  }

  // Here we're checking for error messages generated by compiling declarations.  (The LanguageTest
  // stuff only knows how to check for errors that come from commands and reporters.).  Also, we
  // want to do lots of similar tests, so rather than copy-and-paste them in a .txt file, we
  // generate the tests on the fly.

  def testBadName(name: String, error: String, headerSource: String = "") {
    test("bad name: " + name) { fixture =>
      import fixture._
      def compile(source: String) {
        val ex = intercept[api.CompilerException] {
          compiler.compileProgram(
            source, api.Program.empty, workspace.getExtensionManager)
        }
        assertResult(error)(ex.getMessage)
      }
      compile(headerSource + "\nto " + name + " end")
      compile(headerSource + "\nto foo [" + name + "] end")
    }
  }

  testBadName("fd",
    "There is already a primitive command called FD")
  testBadName("turtles",
    "There is already a primitive reporter called TURTLES")
  testBadName("???",
    "Names beginning with ? are reserved for use as task inputs")
  testBadName("kitten",
    "There is already a breed called KITTEN", "breed [kittens kitten]")
  testBadName("kittens",
    "There is already a breed called KITTENS", "breed [kittens kitten]")
  testBadName("turtles-at",
    "There is already a primitive reporter called TURTLES-AT")
  testBadName("shell",
    "There is already a TURTLES-OWN variable called SHELL",
    "turtles-own [shell]")
  testBadName("silliness",
    "There is already a KITTENS-OWN variable called SILLINESS",
    "breed [kittens kitten] kittens-own [silliness]")
  testBadName("weight",
    "There is already a EDGES-OWN variable called WEIGHT",
    "undirected-link-breed [edges edge] " +
      "breed [nodes node] " +
      "breed [monsters monster] " +
      "edges-own [weight] " +
      "nodes-own [weight] " +
      "monsters-own [weight]")
  testBadName("end1",
    "There is already a link variable called END1")
  testBadName("size",
    "There is already a turtle variable called SIZE")
  testBadName("color", // well, is actually both turtle and link variable - ST 5/16/03
    "There is already a turtle variable called COLOR")
  testBadName("pcolor",
    "There is already a patch variable called PCOLOR")

  // at least we get errors on these, but the messages aren't great
  // https://github.com/NetLogo/NetLogo/issues/352
  testBadName("kittens-at",
    "There is already a _breedat:KITTENS called KITTENS-AT",
    "breed [kittens kitten]")
  testBadName("array:set",
    "There is already a _extern:+0 called ARRAY:SET",
    "extensions [array]")

}
